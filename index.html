<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Canvas 繪圖工具 RWD 修正版</title>
<style>
  body { 
    margin: 0; 
    padding: 0;
    font-family: Arial, sans-serif; 
    background: #f0f0f0;
    min-height: 100vh;
    overflow-x: auto;
    touch-action: auto;
  }
  
  .header {
    text-align: center;
    padding: 10px 0;
    background: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    z-index: 10;
    width: 100vw;
    box-sizing: border-box;
  }
  
  .controls { 
    margin: 10px 0; 
    padding: 0 10px;
    display: flex; 
    flex-wrap: wrap; 
    justify-content: center; 
    gap: 5px;
    width: 100%;
    box-sizing: border-box;
  }
  
  .color-btn { 
    width: 30px; 
    height: 30px; 
    display: inline-block; 
    cursor: pointer; 
    border: 1px solid #ccc; 
    border-radius: 3px;
  }
  
  .main-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: calc(100vh - 200px);
    padding: 20px 0 50px 0;
    box-sizing: border-box;
  }
  
  #canvasContainer { 
    position: relative;
    width: 100vw;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0;
    touch-action: none;
    overflow: visible;
    min-height: 400px;
  }
  
  canvas { 
    border: 2px solid #333;
    position: absolute !important; 
    top: 0 !important; 
    left: 0 !important; 
    touch-action: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    border-radius: 5px;
    transform-origin: center center;
    transition: none;
    display: block !important;
    z-index: 1;
  }
  
  .upload-section { 
    margin: 10px 0; 
    padding: 10px; 
    background: white; 
    border-radius: 5px; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    width: 100%;
    box-sizing: border-box;
  }
  
  .upload-btn { 
    margin: 5px; 
    padding: 8px 15px; 
    background: #4CAF50; 
    color: white; 
    border: none; 
    border-radius: 4px; 
    cursor: pointer;
    font-size: 14px;
  }
  
  .upload-btn:hover { 
    background: #45a049; 
  }
  
  .upload-btn.bg { 
    background: #2196F3; 
  }
  
  .upload-btn.bg:hover { 
    background: #0b7dda; 
  }
  
  .upload-btn.line-art { 
    background: #FF6B35; 
  }
  
  .upload-btn.line-art:hover { 
    background: #E55A2B; 
  }
  
  .processing-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    z-index: 1000;
    display: none;
  }
  
  .layer-info { 
    margin: 5px; 
    font-size: 12px; 
    color: #666; 
  }
  
  .control-btn {
    margin: 5px;
    padding: 8px 12px;
    background: #555;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  
  .control-btn:hover {
    background: #333;
  }
  
  .slider-container {
    display: flex;
    align-items: center;
    margin: 5px;
    gap: 10px;
  }
  
  .slider-container input[type="range"] {
    width: 100px;
  }
  
  .sample-images-section {
    margin: 15px 0;
    padding: 15px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    width: 100%;
    box-sizing: border-box;
  }
  
  .section-title {
    font-size: 16px;
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
    text-align: center;
  }
  
  .sample-images-container {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .sample-image-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: all 0.3s ease;
    border: 2px solid transparent;
  }
  
  .sample-image-item:hover {
    background-color: #f0f8ff;
    border-color: #2196F3;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  
  .sample-thumbnail {
    width: 80px;
    height: 80px;
    object-fit: contain;
    border-radius: 6px;
    border: 1px solid #ddd;
    background: white;
    padding: 4px;
  }
  
  .sample-label {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
    text-align: center;
  }
  
  .sample-image-item:hover .sample-label {
    color: #2196F3;
    font-weight: bold;
  }
  
  @media (max-width: 768px) { 
    .color-btn { width: 25px; height: 25px; }
    .main-container {
      padding: 15px 0 30px 0;
    }
    .upload-btn, .control-btn {
      font-size: 12px;
      padding: 6px 10px;
    }
    .sample-thumbnail {
      width: 70px;
      height: 70px;
    }
    .sample-images-container {
      gap: 10px;
    }
  }
  
  @media (max-width: 480px) {
    .controls {
      margin: 5px 0;
      padding: 0 5px;
      gap: 3px;
    }
    .upload-section {
      margin: 5px 0;
      padding: 8px;
    }
    .sample-images-section {
      margin: 10px 0;
      padding: 10px;
    }
    .main-container {
      padding: 10px 0 20px 0;
    }
    .sample-thumbnail {
      width: 60px;
      height: 60px;
    }
    .section-title {
      font-size: 14px;
    }
  }
</style>
</head>
<body>

<div class="header">
  <h2>Canvas 繪圖工具</h2>
  
  <div class="upload-section">
    <div class="layer-info">圖層順序：背景圖 → 畫筆繪圖 → 去背圖（最上層）</div>
    <input type="file" id="uploadBg" accept="image/*" style="display:none" onchange="uploadBackgroundImage(event)">
    <button class="upload-btn bg" onclick="document.getElementById('uploadBg').click()">上傳背景圖</button>
    
    <input type="file" id="uploadOverlay" accept="image/*" style="display:none" onchange="uploadOverlayImage(event)">
    <button class="upload-btn" onclick="document.getElementById('uploadOverlay').click()">上傳去背圖（推薦PNG）</button>
    
    <input type="file" id="uploadToLineArt" accept="image/*" style="display:none" onchange="convertPhotoToLineArt(event)">
    <button class="upload-btn line-art" onclick="document.getElementById('uploadToLineArt').click()">照片轉線稿</button>
    
    <button class="upload-btn" onclick="clearBackground()">清除背景</button>
    <button class="upload-btn" onclick="clearOverlay()">清除去背圖</button>
  </div>

  <div class="controls" id="colorPalette"></div>
  <div class="controls">
    <button class="control-btn" onclick="setEraser()">橡皮擦</button>
    <div class="slider-container">
      <label>粗細：</label>
      <input type="range" id="lineWidth" min="1" max="20" value="1" onchange="changeLineWidth(this.value)">
      <span id="lineWidthValue">1</span>
    </div>
    <button class="control-btn" onclick="undo()">復原</button>
    <button class="control-btn" onclick="redo()">重做</button>
    <button class="control-btn" onclick="clearDraw()">清除畫筆</button>
    <button class="control-btn" onclick="downloadCanvas()">下載合成圖</button>
  </div>

  <div class="sample-images-section">
    <div class="section-title">範例圖片</div>
    <div class="sample-images-container">
      <div class="sample-image-item" onclick="loadSampleImageTest(1)">
        <img src="https://github.com/farmeryi/coloring-game/raw/5f97cd68ce2b0dcd008401d700b110fbadfb685c/seed1.png" alt="範例圖片 1" class="sample-thumbnail">
        <span class="sample-label">範例 1</span>
      </div>
      <div class="sample-image-item" onclick="loadSampleImageTest(2)">
        <img src="https://github.com/farmeryi/coloring-game/raw/5f97cd68ce2b0dcd008401d700b110fbadfb685c/seed2.png" alt="範例圖片 2" class="sample-thumbnail">
        <span class="sample-label">範例 2</span>
      </div>
    </div>
  </div>
</div>

<div class="processing-indicator" id="processingIndicator">
  <div>正在轉換照片為線稿...</div>
  <div style="margin-top: 10px;">請稍候，處理中...</div>
</div>

<div class="main-container">
  <div id="canvasContainer">
    <canvas id="bgCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>
  </div>
</div>

<script>
const bgCanvas = document.getElementById("bgCanvas");
const drawCanvas = document.getElementById("drawCanvas");
const overlayCanvas = document.getElementById("overlayCanvas");

const bgCtx = bgCanvas.getContext("2d");
const ctx = drawCanvas.getContext("2d");
const overlayCtx = overlayCanvas.getContext("2d");

let drawing = false;
let currentColor = "black";
let lineWidth = 1;
let isEraser = false;
let history = [];
let redoHistory = [];
let lastPos = {x:0,y:0};
let bgImage = null;
let overlayImage = null;

// 雙指手勢相關變數
let lastTouchDistance = 0;
let lastTouchCenter = {x: 0, y: 0};
let initialPinchDistance = 0;
let isPinching = false;
let touchStartTime = 0;
let multiTouchActive = false;
let lastTouchEndTime = 0;
let justFinishedMultiTouch = false;

// 畫布縮放和位置相關變數
let canvasScale = 1;
let canvasOffsetX = 0;
let canvasOffsetY = 0;
let minScale = 0.5;
let maxScale = 3;

// 計算兩點間距離
function getTouchDistance(touch1, touch2) {
  const dx = touch1.clientX - touch2.clientX;
  const dy = touch1.clientY - touch2.clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// 計算兩點中心點
function getTouchCenter(touch1, touch2) {
  return {
    x: (touch1.clientX + touch2.clientX) / 2,
    y: (touch1.clientY + touch2.clientY) / 2
  };
}

// 更新畫布變換
function updateCanvasTransform() {
  const transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${canvasScale})`;
  [bgCanvas, drawCanvas, overlayCanvas].forEach(canvas => {
    canvas.style.transform = transform;
  });
}

// 響應式畫布調整
function resizeCanvas(){
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  
  let width, height;
  
  if (bgImage) {
    const imgAspect = bgImage.width / bgImage.height;
    width = viewportWidth;
    height = width / imgAspect;
    
    const maxHeight = viewportHeight * 0.8;
    if (height > maxHeight) {
      height = maxHeight;
      width = height * imgAspect;
    }
  } else {
    width = viewportWidth;
    height = width * 0.75;
    
    const maxHeight = viewportHeight * 0.8;
    if (height > maxHeight) {
      height = maxHeight;
      width = height * (4/3);
    }
  }
  
  [bgCanvas, drawCanvas, overlayCanvas].forEach(c => {
    c.width = width;
    c.height = height;
    c.style.width = width + 'px';
    c.style.height = height + 'px';
    c.style.display = 'block';
    c.style.position = 'absolute';
    c.style.top = '0px';
    c.style.left = '0px';
  });
  
  canvasScale = 1;
  canvasOffsetX = 0;
  canvasOffsetY = 0;
  
  updateCanvasTransform();
  
  bgCtx.fillStyle = '#FFFFFF';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
  
  redrawBackground();
  redrawDrawLayer();
  redrawOverlay();
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', function() {
  setTimeout(resizeCanvas, 100);
});

// 觸控與滑鼠事件
function getPos(e){
  const rect = drawCanvas.getBoundingClientRect();
  let clientX, clientY;
  if(e.touches && e.touches.length === 1){ 
    clientX = e.touches[0].clientX; 
    clientY = e.touches[0].clientY;
  } else { 
    clientX = e.clientX; 
    clientY = e.clientY;
  }
  
  const x = (clientX - rect.left) / canvasScale;
  const y = (clientY - rect.top) / canvasScale;
  
  return { 
    x: x * (drawCanvas.width / (rect.width / canvasScale)),
    y: y * (drawCanvas.height / (rect.height / canvasScale))
  };
}

function startDraw(e){
  touchStartTime = Date.now();
  
  if(e.touches && e.touches.length >= 2) {
    isPinching = true;
    multiTouchActive = true;
    justFinishedMultiTouch = false;
    
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    lastTouchDistance = getTouchDistance(touch1, touch2);
    lastTouchCenter = getTouchCenter(touch1, touch2);
    
    if(drawing) {
      drawing = false;
      ctx.closePath();
    }
    return;
  }
  
  if(e.touches && e.touches.length === 1) {
    if(justFinishedMultiTouch) {
      return;
    }
    
    e.preventDefault();
    drawing = true;
    multiTouchActive = false;
    lastPos = getPos(e);
    ctx.beginPath();
    ctx.moveTo(lastPos.x, lastPos.y);
    return;
  }
  
  if(!e.touches) {
    e.preventDefault();
    drawing = true;
    multiTouchActive = false;
    lastPos = getPos(e);
    ctx.beginPath();
    ctx.moveTo(lastPos.x, lastPos.y);
  }
}

function draw(e){
  if(e.touches && e.touches.length >= 2) {
    isPinching = true;
    multiTouchActive = true;
    
    if(drawing) {
      drawing = false;
      ctx.closePath();
    }
    
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = getTouchDistance(touch1, touch2);
    const currentCenter = getTouchCenter(touch1, touch2);
    
    if(lastTouchDistance > 0 && lastTouchCenter.x > 0) {
      const scaleChange = currentDistance / lastTouchDistance;
      const newScale = canvasScale * scaleChange;
      
      if(newScale >= minScale && newScale <= maxScale) {
        canvasScale = newScale;
      }
      
      const deltaX = currentCenter.x - lastTouchCenter.x;
      const deltaY = currentCenter.y - lastTouchCenter.y;
      
      canvasOffsetX += deltaX;
      canvasOffsetY += deltaY;
      
      updateCanvasTransform();
    }
    
    lastTouchDistance = currentDistance;
    lastTouchCenter = currentCenter;
    return;
  }
  
  if(!drawing || isPinching) return;
  
  const pos = getPos(e);
  ctx.lineWidth = lineWidth;
  ctx.lineCap = "round";
  ctx.strokeStyle = currentColor;
  ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
  ctx.beginPath();
  ctx.moveTo(lastPos.x, lastPos.y);
  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  lastPos = pos;
}

function stopDraw(e){
  lastTouchEndTime = Date.now();
  
  if(isPinching) {
    isPinching = false;
    lastTouchDistance = 0;
    justFinishedMultiTouch = true;
    
    setTimeout(() => {
      justFinishedMultiTouch = false;
      multiTouchActive = false;
    }, 300);
    return;
  }
  
  if(e.touches && e.touches.length > 0) {
    return;
  }
  
  if(drawing) {
    drawing = false;
    ctx.closePath();
    saveHistory();
  }
  
  if(!e.touches || e.touches.length === 0) {
    multiTouchActive = false;
  }
}

// 事件監聽器綁定
drawCanvas.addEventListener("mousedown", startDraw);
drawCanvas.addEventListener("mousemove", draw);
drawCanvas.addEventListener("mouseup", stopDraw);
drawCanvas.addEventListener("mouseout", stopDraw);
drawCanvas.addEventListener("touchstart", startDraw, {passive:false});
drawCanvas.addEventListener("touchmove", draw, {passive:false});
drawCanvas.addEventListener("touchend", stopDraw, {passive:false});

overlayCanvas.addEventListener("mousedown", startDraw);
overlayCanvas.addEventListener("mousemove", draw);
overlayCanvas.addEventListener("mouseup", stopDraw);
overlayCanvas.addEventListener("mouseout", stopDraw);
overlayCanvas.addEventListener("touchstart", startDraw, {passive:false});
overlayCanvas.addEventListener("touchmove", draw, {passive:false});
overlayCanvas.addEventListener("touchend", stopDraw, {passive:false});

// 顏色與橡皮擦
function setColor(color){ currentColor=color; isEraser=false; }
function setEraser(){ isEraser=true; }

// 粗細調整
function changeLineWidth(value){ 
  lineWidth = value; 
  document.getElementById('lineWidthValue').textContent = value;
}

// 清除畫筆層
function clearDraw(){
  ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  saveHistory();
}

// 歷史紀錄
function saveHistory(){
  const imgData = drawCanvas.toDataURL();
  history.push(imgData);
  redoHistory = [];
  if(history.length > 50) history.shift();
}

// 復原
function undo(){
  if(history.length>1){
    redoHistory.push(history.pop());
    const img = new Image();
    img.src = history[history.length-1];
    img.onload = ()=>{
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      ctx.drawImage(img,0,0,drawCanvas.width,drawCanvas.height);
    }
  }
}

// 重做
function redo(){
  if(redoHistory.length>0){
    const imgData = redoHistory.pop();
    const img = new Image();
    img.src = imgData;
    img.onload = ()=>{
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      ctx.drawImage(img,0,0,drawCanvas.width,drawCanvas.height);
    }
    history.push(imgData);
  }
}

// 上傳背景圖片
function uploadBackgroundImage(event){
  const file = event.target.files[0];
  if(!file) return;
  
  if(!file.type.startsWith('image/')){
    alert('請選擇圖片文件！');
    event.target.value = '';
    return;
  }
  
  console.log('上傳背景圖片:', file.name, file.type, file.size);
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      console.log('背景圖片載入成功:', img.width, 'x', img.height);
      bgImage = img;
      resizeCanvas();
    };
    img.onerror = function() {
      alert('圖片載入失敗，請檢查文件格式！');
    };
    img.src = e.target.result;
  };
  reader.onerror = function() {
    alert('文件讀取失敗！');
  };
  reader.readAsDataURL(file);
  
  event.target.value = '';
}

// 上傳覆蓋圖片
function uploadOverlayImage(event){
  const file = event.target.files[0];
  if(!file) return;
  
  if(!file.type.startsWith('image/')){
    alert('請上傳圖片文件（建議使用 PNG 格式以保持透明效果）！');
    event.target.value = '';
    return;
  }
  
  console.log('上傳去背圖片:', file.name, file.type, file.size);
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      console.log('去背圖片載入成功:', img.width, 'x', img.height);
      overlayImage = img;
      redrawOverlay();
      clearSampleSelection();
    };
    img.onerror = function() {
      console.error('圖片載入失敗');
      alert('圖片載入失敗，請檢查文件格式！');
    };
    img.src = e.target.result;
  };
  reader.onerror = function() {
    console.error('文件讀取失敗');
    alert('文件讀取失敗！');
  };
  reader.readAsDataURL(file);
  
  event.target.value = '';
}

// 照片轉線稿功能
function convertPhotoToLineArt(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  if (!file.type.startsWith('image/')) {
    alert('請選擇圖片文件！');
    event.target.value = '';
    return;
  }
  
  console.log('開始轉換照片為線稿:', file.name);
  showProcessingIndicator();
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      console.log('圖片載入完成，開始處理...');
      setTimeout(() => {
        processImageToLineArt(img);
      }, 100);
    };
    img.onerror = function() {
      console.error('圖片載入失敗');
      hideProcessingIndicator();
      alert('圖片載入失敗！');
    };
    img.src = e.target.result;
  };
  reader.onerror = function() {
    console.error('文件讀取失敗');
    hideProcessingIndicator();
    alert('文件讀取失敗！');
  };
  reader.readAsDataURL(file);
  event.target.value = '';
}

// 圖像處理：轉換為線稿
function processImageToLineArt(img) {
  try {
    console.log('開始圖像處理，原始尺寸:', img.width, 'x', img.height);
    
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = overlayCanvas.width;
    tempCanvas.height = overlayCanvas.height;
    
    console.log('處理畫布尺寸:', tempCanvas.width, 'x', tempCanvas.height);
    
    tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
    
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    console.log('獲取圖片數據，像素數量:', imageData.data.length / 4);
    
    console.log('開始處理像素...');
    const processedData = processPixelsForLineArt(imageData);
    
    tempCtx.putImageData(processedData, 0, 0);
    console.log('數據已寫回canvas');
    
    const dataURL = tempCanvas.toDataURL('image/png');
    console.log('生成base64數據，長度:', dataURL.length);
    
    const lineArtImage = new Image();
    lineArtImage.onload = function() {
      console.log('線稿圖片創建成功');
      overlayImage = lineArtImage;
      redrawOverlay();
      clearSampleSelection();
      hideProcessingIndicator();
      console.log('照片轉線稿完成！');
    };
    lineArtImage.onerror = function() {
      console.error('線稿圖片創建失敗');
      hideProcessingIndicator();
      alert('線稿生成失敗！');
    };
    lineArtImage.src = dataURL;
    
  } catch (error) {
    console.error('處理過程中發生錯誤:', error);
    hideProcessingIndicator();
    alert('圖片處理失敗：' + error.message);
  }
}

// 簡化的像素處理函數
function processPixelsForLineArt(imageData) {
  const width = imageData.width;
  const height = imageData.height;
  const data = imageData.data;
  const output = new ImageData(width, height);
  const outputData = output.data;
  
  console.log('開始像素處理，尺寸:', width, 'x', height);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      const current = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
      
      const right = Math.round(0.299 * data[idx + 4] + 0.587 * data[idx + 5] + 0.114 * data[idx + 6]);
      const bottom = Math.round(0.299 * data[idx + width * 4] + 0.587 * data[idx + width * 4 + 1] + 0.114 * data[idx + width * 4 + 2]);
      
      const diffX = Math.abs(current - right);
      const diffY = Math.abs(current - bottom);
      const edgeStrength = Math.max(diffX, diffY);
      
      const threshold = 30;
      
      if (edgeStrength > threshold) {
        outputData[idx] = 0;
        outputData[idx + 1] = 0;
        outputData[
